// Copyright (c) 2024-2025 Accenture, All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Description:
// Create a development instance that developers can connect to for a finite
// time, allowing them to develop builds and investigate issues.

pipeline {

  // Parameters defined in groovy/job.groovy

  agent none

  environment {
    STORAGE_CLASS_SUFFIX="android-${ANDROID_VOLUME}"
    STORAGE_SIZE="${ANDROID_VOLUME =~ "rpi" ? "500Gi" : "1000Gi"}"

    INITIAL_POD_TEMPLATE="${USE_LOCAL_AOSP_MIRROR == "true" ? kubernetesPodTemplateWithMirror : kubernetesPodTemplateWithoutMirror}"
    POD_TEMPLATE="${ANDROID_VOLUME =~ "abfs" ? kubernetesAbfsPodTemplate : INITIAL_POD_TEMPLATE }"

    ABFS_STORAGE_CLASS_SUFFIX="android-abfs"
    ABFS_STORAGE_SIZE="750Gi"

    // Define Pod Template in environment so we can override.
    def kubernetesPodTemplateWithoutMirror = """
      apiVersion: v1
      kind: Pod
      metadata:
        annotations:
          cluster-autoscaler.kubernetes.io/safe-to-evict: "true"
        labels:
          aaos_pod: "true"
      spec:
        tolerations:
        - key: workloadType
          operator: Equal
          value: android
          effect: "NoSchedule"
        affinity:
          podAntiAffinity:
            requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                - key: aaos_pod
                  operator: Exists
              topologyKey: kubernetes.io/hostname
        hostname: jenkins-aaos-build-pod
        serviceAccountName: ${JENKINS_SERVICE_ACCOUNT}
        containers:
        - name: builder
          image: ${CLOUD_REGION}-docker.pkg.dev/${CLOUD_PROJECT}/${ANDROID_BUILD_DOCKER_ARTIFACT_PATH_NAME}:${IMAGE_TAG}
          imagePullPolicy: Always
          securityContext:
            privileged: true
            appArmorProfile:
              type: Unconfined
          command:
          - sleep
          args:
          - 10h
          resources:
            limits:
              cpu: 4000m
              memory: 16Gi
            requests:
              cpu: 4000m
              memory: 16Gi
          volumeMounts:
            - mountPath: /aaos-cache
              name: aaos-cache
        volumes:
          - name: aaos-cache
            ephemeral:
              volumeClaimTemplate:
                spec:
                  storageClassName: ${JENKINS_AAOS_BUILD_CACHE_STORAGE_PREFIX}-${STORAGE_CLASS_SUFFIX}
                  resources:
                    requests:
                      storage: ${STORAGE_SIZE}
                  accessModes:
                    - ReadWriteOnce
         // nodeSelector:
    """.stripIndent()

    // Pod template with AOSP Mirror volume mounted as read-only
    def kubernetesPodTemplateWithMirror = """
      apiVersion: v1
      kind: Pod
      metadata:
        annotations:
          cluster-autoscaler.kubernetes.io/safe-to-evict: "true"
        labels:
          aaos_pod: "true"
      spec:
        tolerations:
        - key: workloadType
          operator: Equal
          value: android
          effect: "NoSchedule"
        affinity:
          podAntiAffinity:
            requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                - key: aaos_pod
                  operator: Exists
              topologyKey: kubernetes.io/hostname
        hostname: jenkins-aaos-build-pod
        serviceAccountName: ${JENKINS_SERVICE_ACCOUNT}
        containers:
        - name: builder
          image: ${CLOUD_REGION}-docker.pkg.dev/${CLOUD_PROJECT}/${ANDROID_BUILD_DOCKER_ARTIFACT_PATH_NAME}:latest
          imagePullPolicy: Always
          securityContext:
            privileged: true
            appArmorProfile:
              type: Unconfined
          command:
          - sleep
          args:
          - 5h
          resources:
            limits:
              cpu: 4000m
              memory: 16Gi
            requests:
              cpu: 4000m
              memory: 16Gi
          volumeMounts:
            - mountPath: /aaos-cache
              name: aaos-cache
            - mountPath: ${AOSP_MIRROR_PRESET_FILESTORE_PVC_MOUNT_PATH_IN_CONTAINER}
              readOnly: true
              name: ${AOSP_MIRROR_PRESET_FILESTORE_PVC_NAME}
        volumes:
          - name: aaos-cache
            ephemeral:
              volumeClaimTemplate:
                spec:
                  storageClassName: ${JENKINS_AAOS_BUILD_CACHE_STORAGE_PREFIX}-${STORAGE_CLASS_SUFFIX}
                  resources:
                    requests:
                      storage: ${STORAGE_SIZE}
                  accessModes:
                    - ReadWriteOnce
          - name: ${AOSP_MIRROR_PRESET_FILESTORE_PVC_NAME}
            persistentVolumeClaim:
              claimName: ${AOSP_MIRROR_PRESET_FILESTORE_PVC_NAME}
         // nodeSelector:
    """.stripIndent()

    def kubernetesAbfsPodTemplate = """
      apiVersion: v1
      kind: Pod
      metadata:
        annotations:
          cluster-autoscaler.kubernetes.io/safe-to-evict: "true"
        labels:
          aaos_abfs_pod: "true"
      spec:
        tolerations:
        - key: workloadType
          operator: Equal
          value: android-abfs
          effect: "NoSchedule"
        affinity:
          podAntiAffinity:
            requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                - key: aaos_abfs_pod
                  operator: Exists
              topologyKey: kubernetes.io/hostname
        hostname: jenkins-abfs-build-pod
        serviceAccountName: ${JENKINS_SERVICE_ACCOUNT}
        containers:
        - name: builder
          image: ${CLOUD_REGION}-docker.pkg.dev/${CLOUD_PROJECT}/${ABFS_BUILD_DOCKER_ARTIFACT_PATH_NAME}:latest
          imagePullPolicy: Always
          securityContext:
            privileged: true
          command:
          - sleep
          args:
          - 5h
          volumeMounts:
            - mountPath: /aaos-cache
              name: aaos-cache
        volumes:
          - name: aaos-cache
            ephemeral:
              volumeClaimTemplate:
                spec:
                  storageClassName: ${JENKINS_AAOS_BUILD_CACHE_STORAGE_PREFIX}-${ABFS_STORAGE_CLASS_SUFFIX}
                  resources:
                    requests:
                      storage: ${ABFS_STORAGE_SIZE}
                  accessModes:
                    - ReadWriteOnce
         // nodeSelector:
    """.stripIndent()

  }

  stages {
    stage ('Start VM Instance') {
      agent { kubernetes { yaml "${POD_TEMPLATE}" } }
      stages {
        stage ('MTK Connect to Host Device') {
          when { expression { env.MTK_CONNECT_ENABLE == 'true' } }
          steps {
            script {
              currentBuild.description = "$BUILD_USER"
            }
            container(name: 'builder') {
              catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                withCredentials([usernamePassword(credentialsId: 'jenkins-mtk-connect-apikey', passwordVariable: 'MTK_CONNECT_PASSWORD', usernameVariable: 'MTK_CONNECT_USERNAME')]) {
                  sh '''
                    cd ./workloads/common/mtk-connect/ || true
                    sudo \
                    MTK_CONNECT_DOMAIN=${HORIZON_DOMAIN} \
                    MTK_CONNECT_USERNAME=${MTK_CONNECT_USERNAME} \
                    MTK_CONNECT_PASSWORD=${MTK_CONNECT_PASSWORD} \
                    MTK_CONNECTED_DEVICES=${NUM_HOST_INSTANCES} \
                    MTK_CONNECT_TESTBENCH="${JOB_NAME}-${BUILD_NUMBER}" \
                    MTK_CONNECT_TESTBENCH_USER=$([ "$MTK_CONNECT_PUBLIC" = "true" ] && echo "everyone" || echo "$BUILD_USER_ID") \
                    MTK_CONNECT_CONTAINER_ONLY="true" \
                    MTK_CONNECT_HOST_ONLY="true" \
                    timeout 15m ./mtk_connect.sh --start
                    cd - || true
                  '''
                }
              }
            }
          }
        }

        stage ('Retain instance') {
          when { expression { env.INSTANCE_MAX_UPTIME } }
          steps {
            container(name: 'builder') {
              catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                script {
                  sleep(time: "${INSTANCE_MAX_UPTIME}", unit: 'HOURS')
                }
              }
            }
          }
        }

        stage ('Stop Virtual Devices') {
          when { expression { env.MTK_CONNECT_ENABLE == 'true' } }
          steps {
            container(name: 'builder') {
              catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                withCredentials([usernamePassword(credentialsId: 'jenkins-mtk-connect-apikey', passwordVariable: 'MTK_CONNECT_PASSWORD', usernameVariable: 'MTK_CONNECT_USERNAME')]) {
                  script {
                    sh 'echo "Stopping  MTK Connect"'
                    sh '''
                      cd ./workloads/common/mtk-connect/ || true
                      sudo \
                      MTK_CONNECT_DOMAIN=${HORIZON_DOMAIN} \
                      MTK_CONNECT_USERNAME=${MTK_CONNECT_USERNAME} \
                      MTK_CONNECT_PASSWORD=${MTK_CONNECT_PASSWORD} \
                      MTK_CONNECTED_DEVICES="1" \
                      MTK_CONNECT_TESTBENCH="${JOB_NAME}-${BUILD_NUMBER}" \
                      MTK_CONNECT_CONTAINER_ONLY="true" \
                      timeout 10m ./mtk_connect.sh --stop || true
                      cd - || true
                    '''
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
